[
["index.html", "VSTS for Analysis Preface 0.1 Overview 0.2 Ways of Working", " VSTS for Analysis Preface 0.1 Overview This book aims act as a resource for analysts on how and why they should use version control. It is in the context of the Department for Education Corporate environment and focusses on using Git and Visual Studio Team Services (the departments existing code version control tool of choice). R and R Studio are used as code base we are version controlling and IDE and the examples will be a mix of using R studio and the command line. 0.2 Ways of Working On a high level this resource is advocating a new way of working for analytical projects which can be summarised as follows: Plan your workload up front - This will help you not only better understand the project but write less, better code to get the job done. Take one task at a time - Focus on one specific item of work at a time (substantial enough that it warrants being its own task but not so large that its not clear what has change). Once its complete get it reviewed and move onto the next one. e.g. create a script that imports and cleans all of the data sources. Collaborate - Distribute distinct items of work across analysts and bring these together to build the final product and enforce code review when there is a proposal to change the main version of the code. Do this in a systemised manner - Utilise the de facto tools for the job so that doing this is not a big overhead and can be effectively managed. "],
["intro.html", "Chapter 1 Introduction 1.1 Background 1.2 Manual Version Control 1.3 Git 1.4 Collaboration 1.5 Visual Studio Team Services", " Chapter 1 Introduction 1.1 Background Version control is an important part of any project. It allows you to respond reactively to requests for changes, ensure that you can easily reproduce an earlier iteration and provides an audit trail of what work has been done and the decisions that have been made. Most people would recognise this and probably are doing some form of their own version control to ensure they are able to respond, albeit not immediately, to these situations. As analytical functions move away from software such as Excel, SPSS, etc. towards fully code-based solutions using languages such as R, Python, SQL, etc. there is a wealth of pre-established expertise that can be lifted from traditional software development practices. Git is the most recognised software for ensuring version control is done in a standardised manner and there are a wealth of applications that allow you easily to adapt its use to your needs. 1.2 Manual Version Control Any book illustrating the usefulness of Git will start with an example similar to the following. This approach creates versioned files using suffixes with some sort of convention. This can work if you have a small number of iterations but the following questions need to be answered: Which is the final version?! - Although conventions attempt to remain standard you will get to a stage when you think you are final, another change will come and your previous convention will be broken. What files actually constitute this analysis? - Folder structure changes over time. Scripts merge, are broken down into subscripts and files that may no longer be needed could be sitting in your folder. For a colleague quality assuring your work or anyone (including yourself) picking this up in the future, this structure is not going to help you as it will be unclear what is really needed. What are the differences between these versions? - Although these versions have different numbers we can’t easily tell what the difference between them are and would have to manually compare differences to see what’s going on. There is no indication that these are linked to specific items of work. How do you collaborate using this structure? - Collaborating using this sort of versioning means you are going to have to introduce others to this structure and/or manage the process of adding pieces of code, likely passed across via email. Keeping track of this adds to the challenge. The main take home points from this is that there are lots of challenges that come with this, and these challenges can take away from the task at hand. The bigger your project grows, the more challenging this will be. 1.3 Git Git is the most commonly used version control system for code development in the world today. It is command line software, language agnostic and at its root, just looks at differences between plain text files. At its most basic level Git allows the following: Commits - Create checkpoints in your code development process that you can go back to if required. Branch - Create exact replicas of your project folder in which you can try out particular ideas without editing the main version. Merge - Systematically merge these changes back into the main version of the code. Git has the ability to check the differences between 2 versions. This is invaluable information and means that rather than checking the whole project code at an undetermined time in a project the task becomes: What changed since the last working version, was that done right and does that change impact anywhere else?. Note: Git is command line software but many development environments (including R Studio) provide the functionality via the graphical user interface. 1.4 Collaboration So far we have only looked at local version control. This is great for yourself to go back to previous versions of your work but doesn’t really offer a solution to collaborative coding. What is needed is a visual platform where central versions of the code can be stored with the following functionality: Users can take copies of the code on their local machine. Users can make changes to the code locally and submit those changes for review. The review process can be managed and if any changes are required they can be made in a systemised manner. You can think of these sort of systems as wrappers for Git, where merges into the main version of the code are safeguarded. One of the most well known systems for this is GitHub which is popular with open source projects. For the purposes of this book we are looking at using Visual Studio Team Services. This is a common tool in enterprise for software development and the reason we use it over GitHub is that it is secure. 1.5 Visual Studio Team Services Visual Studio Team Services (VSTS) is a code collaboration tool for managing projects consisting of multiple developers. This is not a natural tool to use with Open Source Statistical Programming tools such as R and there isn’t too much guidance around on using it for the specific purpose of R projects. That said, VSTS is code agnostic. Although not aimed at R directly, it does provide the functionality to manage any Git-controlled project effectively. On top of this, it provides project management functionality that when coupled with a Git workflow encourages well planned and executed projects, where each commit is a specific item of work. This functionality is optional but is encouraged. "],
["version-control-using-git-the-basics.html", "Chapter 2 Version Control Using Git - The Basics 2.1 Background 2.2 Installing Git 2.3 Opening Git BASH 2.4 Setting up Git 2.5 Navigating with Git BASH 2.6 Setting up a Git repository 2.7 Applying Git to a Project 2.8 Adding and committing files 2.9 Viewing the history 2.10 Making branches 2.11 Merging branches 2.12 Branching Workflow 2.13 Merge conflicts", " Chapter 2 Version Control Using Git - The Basics 2.1 Background Git is a program used to version control your files - it can be used for any files, but works best for flat text files (anything that you can open in Notepad that will show actual text - .txt, .csv, .sql, .R, .Rmd etc.) instead of binary files (anything that shows gibberish when opened in Notepad - .docx, .xlsx etc.). There are many ways to use Git, but they fall into two main categories, command line and graphical user interface (GUI). Command line interfaces of Git look like the Windows Command Prompt (or Terminal on Mac). By default the Git installation includes a command line interface called Git BASH that you can use Git from. BASH is a command line interface originally for Unix based operating systems that uses a slightly different syntax to the Windows Command Prompt. Once installed, you can also use Git from Command Prompt or Powershell, but Git BASH has a helpful colour scheme that highlights important Git features and, in my opinion, more intuitive commands. If you would prefer to use a GUI you can choose to install one when installing Git. You can also use RStudio, Sourcetree or a whole host of other GUIs with Git. GUIs can be used by pointing and clicking, whereas the command line involves memorising some commands. Despite this, this tutorial will use the command line - Git BASH specifically. This is because the command line is the most versatile interface (it will get you out of trouble when things mess up!) and, once you learn the command line, you’ll be able to apply your skills to any GUI pretty easily. 2.2 Installing Git You can download the Git from here https://git-scm.com/downloads by clicking on your operating system of choice. Once downloaded, open up the installer and follow it through - the default settings should be fine. 2.3 Opening Git BASH You can open up Git BASH from File Explorer by right clicking in a folder and clicking “Git Bash Here”. This will open up a black command window with coloured text. The folder you opened Git BASH in will appear in yellow text - this is the folder that Git is “pointed” at. You run commands in Git BASH by typing them in and pressing enter. 2.4 Setting up Git When you first install Git it is advised to perform some set up steps - they aren’t necessary, but will be useful. First of all type git config --global user.name &lt;Your Name&gt; and then git config --global user.email &lt;You Email&gt; This will add your name and email to each commit you make, which will prove useful when collaborating. You can also set the default text editor to Notepad by copying in git config --global core.editor &quot;C:Windows/system32/notepad.exe&quot; Or, if you have Notepad++ installed you could use that instead by copying in git config --global core.editor &quot;&#39;C:/Program Files (x86)/Notepad++/notepad++.exe&#39; -multiInst -notabbar -nosession -noPlugin&quot; Note, Ctrl+C and Ctrl+V don’t work for copy/pasting in Git BASH, but you can still right click to copy/paste. 2.5 Navigating with Git BASH Once in Git you can navigate through folders from the command line. Typing cd &lt;path&gt; and pressing enter will navigate to a folder path of your choice. Use doubles quotes for files paths with spaces in. You can use cd .. to move “up” one folder and ls to list everything in your current folder. When navigating with Git BASH you can press TAB to autocomplete a folder or file. 2.6 Setting up a Git repository A Git repository is simply a folder that Git is tracking the changes in - it looks just like any other folder in File Explorer, but in Git BASH there will be some cyan text after the file path. Open Git in a folder you would like to make a project in. Next type: git init This will turn this normal folder into a Git Repository - some cyan text saying “master” will appear after the yellow file path. This folder is now ready to start a version controlled project! 2.7 Applying Git to a Project Let’s make a toy R project that we can version control. Make an R project in the same folder as the Git repository from above. The folder will now have an .Rproj file and a .gitignore file (we’ll get to this later). Let’s create some code to plot the stopping distance of cars at different speeds - this data is pre-installed in a data set called “cars”. The code should look something like this: library(ggplot2) data &lt;- cars cars_plot &lt;- ggplot(data, aes(x = speed, y = dist)) + geom_point() cars_plot This will make a simple scatter plot (and hopefully convince you not to speed…). This seems like a good place to record our progress: save your file as “speed_dist.R” in your project folder. Now we can use Git to take a record of this save lest we need it in the future. 2.8 Adding and committing files In Git BASH type git add . This tells Git that we want to record the changes to the folder. We could type all the file names that we want to keep track of, but the dot after add adds everything. Next we actually commit the change: git commit -m &quot;Added speed_dist.R&quot; Here -m means we want to add a comment and &quot;Added speed_dist.R&quot; is our comment to tell us what the commit involved - you could write anything you wanted for the comment. Let’s make a change to the code. Add ggsave(&quot;cars_plot.png&quot;, cars_plot) to the end of your code in speed_dist.R. When run, this will save your plot as cars_plot.png in your project folder. Let’s use Git to record these changes. First type git status this will show us all the files that have changed, or been created since your last commit. It should say that speed_dist.R has been modified and cars_plot.png is “untracked”. As mentioned earlier, Git deals best with flat text files, of which a .png file is not. Because of this, we won’t tell Git about the .png file, only the changes to the speed_dist.R code. This is okay though, because so long as we have the code we can always recreate the image. Use git add speed_dist.R to add just speed_dist.R (notice how last time we used git add . to add everything, but explicitly named the file here). As before we want to commit these changes: git commit -m &quot;Added save feature to speed_dist.R&quot; The workflow for making changes is as follows: Change you files Save your files Add the files you changed in Git Commit the changes in Git 2.9 Viewing the history So far we’ve made two commits. These commits start building up a history in Git. We can view a log of this history using: git log It will show the date, time, commit message, author and hash (the long list of characters in yellow) for each commit made. 2.10 Making branches There may come times when you are working to make two (or more) sets of code changes at the same time. To make sure that you don’t get confused about which change you are making Git has a feature called branches. Branches are also very useful when collaborating with others, when multiple people are making changes at once. Let’s say we want to make two changes at once to the code above: Currently the speed is in mph and the distance in feet, let’s change it to kmp and meters. Let’s add some labels to the axes on the plot and a title. We could just make these changes one at a time as before, but if we want someone to review just each change at once it’s easier if we use branches. So far we’ve just been working on the “master” branch - that’s what the cyan text is all about - which you can think of as more of a trunk than a branch, it’s what we’d regard of as the most up to date and complete version of the code. Let’s make a new branch for our unit conversion work. To create a new branch type in git branch unit_conversion We can type git branch again to see all the available branches. There should now be two, “master” and “unit_conversion”. To switch branches type: git checkout unit_conversion The cyan text should now say “unit_conversion”. Here we can make changes for converting units and commit them without changing the master branch. After the line data &lt;- cars copy in the following code: # convert speed to lph data$speed &lt;- data$speed*1.609344 # convert distance to meters data$dist &lt;- data$dist*0.3048 We can now add and commit these changes as before. Use git log to see the log with these new changes. Let’s switch back to the master branch: git checkout master and look at the log git log Our unit_conversion changes aren’t there! Don’t worry this is what we want - we’ll come back to this later. For now, let’s make a new branch for the plot labels. git branch plot_labels git checkout plot_labels After the geom_point() line add + labs(x = &quot;Speed (mph)&quot;, y = &quot;Stopping Distance (m)&quot;, title = &quot;Stopping distance against speed&quot;) + theme_minimal() and add and commit these changes (remember, only add speed_dist.R!). We now have two separate branches with different changes. We could ask people to review each of these separate branches individually. 2.11 Merging branches Once someone has QA’d our code we can merge our branches into the master branch. Checkout the master branch. Merge the branches one at a time like this git merge unit_conversion git merge plot_labels If we look at the log all the changes from both of these branches should be visible. Note, you log might be getting long enough to run off the page. If so you can go up and down the log with the arrow keys and pressing “q” will allow to you begin typing again. You can now delete the other branches. git branch -d plot_labels git branch -d unit_conversions 2.12 Branching Workflow The branching workflow goes like this: For each large scale change make a branch Checkout the branch Change/save/add/commit as usual Checkout the master branch Merge changes from working branch into master branch Delete the working branch Start all over again for the next change 2.13 Merge conflicts Sometimes, after trying to merge two branches Git will say there are “merge conflicts”. This means that both branches changed the same line of code and Git doesn’t know which one to keep. To understand how to handle merge conflicts we’ll create one! Make a new branch called “blue_is_great” and another called “red_is_great”. Checkout out the “blue_is_great” branch and change the line with geom_point() in to geom_points(colour = &quot;blue&quot;) Save, add and commit these changes. Checkout the “red_is_great” branch and change the same line to geom_points(colour = &quot;red&quot;) Save, add and commit these changes. Let’s try to merge these into the master branch git checkout master git merge red_is_great So far so good. git merge blue_is_great You’ll get some kind of error. Something along the lines of CONFLICT... automatic merge failed... and the cyan branch text will say master|MERGING. If we open speed_dist.R there’ll be a line saying &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD then one version of our changed line then a bunch of equals after which we’ll see the other version of our line and then &gt;&gt;&gt;&gt;&gt;&gt;&gt; blue_is_great. Thankfully, when Git finds a merge conflict it keeps both versions of the line in question so we can decide which one is right. I think red is better than blue, so let’s get rid of the line that makes the colour blue and all the other extraneous lines. Now all we do the usual sh git add and sh git commit. Make note of the merge conflict in the commit message, something like “Fixed merge conflict between blue and red”. For very large and complex merge conflicts it’s worth searching for &lt; HEAD to find all the instances of a conflict. ##.gitignore As the number of files in our project increases it will become tiresome typing in each file we would like to track. git add file1.txt file2.txt ... file37.txt ... We could just use git add . but that would include files that we don’t want to track (like the .png we saved). The .gitignore file is a list of files that Git will ignore (hence the name), no matter how they change, allowing us to use git add . without worrying about files we don’t want to add. As mentioned earlier, a .gitignore file was created with our R Project. You can view this file in any text editor (including RStudio) and, if you do, you will see something like this: .Rproj.user .Rhistory .RData .Ruserdata These are files that RStudio creates that are of little interest in the long run - they change very frequently and aren’t necessary for someone else to run your code. Let’s add to this to tell Git to ignore the image we saved earlier. There are a few ways to do this: We could list the file exactly as it is: car_plot.png We could use a wildcard for the file name so all .png files are ignored: *.png Using the second method will be more robust in the long run because we won’t need to update it if new images are added. Add a new line to .gitignore that says “*.png&quot; and save it. In Git BASH, typing git status will no longer show the image! In non-R projects you can create your own .gitignore file in a text editor and save it in your project folder. "],
["vsts-the-basics.html", "Chapter 3 VSTS - The Basics 3.1 Background 3.2 Theory 3.3 Generating Git Credentials 3.4 Creating a VSTS Project 3.5 Project Setup 3.6 Adding users to a project 3.7 Branch Policies 3.8 Work Items 3.9 Pull Requests", " Chapter 3 VSTS - The Basics 3.1 Background So far we have only looked at Git in the context of local projects and command line software. This alone doesn’t make collaborating on code easy. What is needed is a central platform where people can request for changes to be made to the code base and update their code based on changes by others. This concept in Git is known as remotes. The following are examples of interactive services that allow you to manage Git projects effectively: GitHub Bitbucket GitLab Visual Studio Team Services. We are using Visual Studio Team Services as this is the Department’s tool of choice for internal version control. We would use platforms such as GitHub for our more publicly facing projects (such as this book). VSTS offers unlimited private repositories for 5 users. If you sign up via your corporate email you can create a site that is secure within the organisations active directory and store your code securely. 3.2 Theory At a high level when you are using VSTS (or any type of remote) you are creating a central copy of your code on a server (the VSTS site). The aim of any project is to get your final complete code on to the master branch of the server copy. Analysts will still make and run all their changes locally but will then use the concepts of pushing, pulling and pull requesting to get the VSTS version up to date. Having this central repository and the approval processes that VSTS provides means that multiple analysts can work on a project at the same time and systematically merge all their changes into the final version after code review. The following diagram illustrates the concept of server and local copies. 3.3 Generating Git Credentials Before we get started we can create some credentials to log our local Git client into VSTS. We will be prompted for these when we first try to push to VSTS. To do this you need do the following: Click on your user icon on the top right Hit Security Hit Personal Access Tokens Create Credentials The following clip outlines the process: 3.4 Creating a VSTS Project To set up a repository on VSTS you simply hit new project on the homepage and fill in the project details. This will create you an empty Git repo on VSTS. The following clip outlines the process: Note: Not all users will have permissions to create projects on VSTS. They will instead ask for them to be created by their VSTS admin. 3.5 Project Setup When you first create a VSTS project it will create a blank repo. You then have multiple options on what to do from there. The Two main options are Clone to your computer (cloning will be explained in Cloning a repository) Push an Existing repository 3.5.1 Clone to your computer To clone the blank repository to your computer you can simply copy the VSTS Git repo address from the project start page. e.g. git clone teachers-analysis-unit.visaulstudio.com/_git/example-project Note: If the project you have joined is already in progress you can get the Git repo link from the files section under the code tab. This is different to GitHub where the Git repo is the project home page. 3.5.2 Push an Existing Repository If you have already been working on a project locally you may wish to push this up and use this as the starting point for the collaborative workflow. In order to Push an existing repository you need to do the following: Select the or push an existing repository from the command line option Git Bash in your local Git repo Copy the code and run it This will set up the connection to VSTS and push an entire copy of the repo up to VSTS. The following clip outlines this process: Note: The first time you do this you will be asked for VSTS credentials created previously. 3.6 Adding users to a project VSTS is a locked down code environment where users need to first be given permission to access the site as a whole and then individual projects. To add users to a project you simply do the following on a project home page: Click + button under members Search for user Hit Add The user will then get a welcome email inviting them to the project. The following clip outlines this process: 3.7 Branch Policies At this point you will have a project that anyone who is a member of has the ability to push directly to the master branch. This resource is promoting a workflow in which code is reviewed throughout the development life cycle. Pushing to master doesn’t allow this directly. Instead what we do is set Branch Policies which force code to be reviewed in VSTS before it can be merged into master. This comes with various options which are summarised below: Requiring a minimum number of reviewers - how many people need to approve the code before it can be merged. Checking for linked work items - Does the pull request need to have a work item linked Checking for comment resolution - Do all of the comments on the pull request need to be resolved before merging is approved Merge Strategy - Do you want to enforce a merge strategy. Build testing - not currently explored. It is recommended that you enforce all of the first 3 options and set the Merge Strategy to Squash. A squash merge stategy squashes all commits you made in a branch on your pull request into one for the whole pull request when merged. This ensures a clean working history rather than lots of minor changes. The following clip outlines setting branching policies: 3.8 Work Items VSTS has rich project management functionality that can be used to manage projects of all sizes. At it’s most complex you can utilise a mix of Epics, Stories, Features, Tasks, Issues and User stories to manage your project. These terms and planning stages for a project come from traditional software development and are likely not necessary when using the platform for Data Analysis. Instead we recommend treating features as the main type of work item and breaking your workload down into a number of features. This is similar to what you would do on GitHub with Issues. With features you can again add lots of metadata but the most useful will be the following: Name Description Assigned to There are then numerous ways to visualise work allocations across VSTS ranging from individual task assignments to project boards (similar to trello boards). By utilsing work items you take out the need for tracking tasks manually and can link them to later as will be illustrated later.s The following outlines adding a work item to the example project: 3.9 Pull Requests A pull request is the final, and probably most important, part of VSTS functionality that we are going to cover. A pull request in effect provides a wrapper for the git merge command outlined in Chapter 2. The visual interface allows you to do the following: Give background to the changes made and link any work items (can be enforced as recommended previously). Allow you to assign a colleague to conduct a code review on the changes made Provide a platform for you to discuss the changes and resolve any requests for changes. Presents the differences between the two branches in a visual manner (added/removed) so that you can easily see exactly what has been changed. The following clip outlines the process of opening a pull request: "],
["vsts-workflow.html", "Chapter 4 VSTS - Workflow 4.1 Starting VSTS project 4.2 Making Branches 4.3 Making Changes 4.4 Merging 4.5 Push changes to VSTS", " Chapter 4 VSTS - Workflow 4.1 Starting VSTS project Make a project in VSTS Clone the repository to a local directory. Open your desired folder in File Explorer, right click and select “Git Bash here”. git clone &lt;project_name&gt; We recommend that, to get the most from VSTS, you use it from the start of a project. This allows a continuous process of making small changes and having them QA’d, instead of doing a huge QA right at the end. However, you may have started a repository locally and wish to put it on VSTS. In that case you can push to VSTS. Add the VSTS repository as your “remote” git remote add origin &lt;repo_URL&gt; Push your local changes up to VSTS (make sure you’ve committed your changes first!) git push -u origin --all &lt;repo_URL&gt; 4.2 Making Branches Work may be assigned to you as a “Work Item”. In VSTS use the link to make new branch. To correct a bug, prefix the branch name with “bug/”. To add new functionality, prefix the branch name with “feature/”. Make sure your master branch is up to date. git pull Your local repository will now “know” about the branch you just made. Checkout the branch you made on VSTS (make sure the branch names are the same). git checkout &lt;your_branch_name&gt; 4.3 Making Changes Make your code changes Commit your changes. You can make as many commits as you need to. As ever, make them roughly self-contained chunks that would be easy for someone to review piece by piece. git add &lt;file_list&gt; git commit -m &quot;Commit message&quot; 4.4 Merging When you’ve made enough changes to complete your work item checkout the master branch in your local repository do a pull in case anyone else had made changes. git checkout master git pull Switch back to your working branch. Merge any changes from master. git checkout &lt;your_branch_name&gt; git merge master Sort out any merge conflicts. sh git status will list the files that have merge conflicts. Open the files with the conflicts, and search them for “&lt;&lt;&lt;&lt;”. Everything from the next line up until a line of “====” will be from the master branch. Everything from the “====” line until “&gt;&gt;&gt;&gt;” will be from your working branch. Work through the code to make sure that you keep all the necessary changes. There may be changes from master and your branch that you want to keep, so don’t just idly delete things! Add and commit the changes. git add &lt;file_to_be_merged&gt; git commit -m &quot;Commit message (it&#39;s advised to mention the merge)&quot; 4.5 Push changes to VSTS Push your changes to VSTS git push On VSTS make a pull request for your branch Have someone review your work. If any changes are required, go back to Making Changes and work from there again. Merge your branch into Master Find some more work, go back to the top and start again, Sisyphus! "]
]
